{"id":542718247,"lang":"cpp","time":"5 months, 3 weeks","timestamp":1629692105,"status_display":"Accepted","runtime":"28 ms","url":"/submissions/detail/542718247/","is_pending":"Not Pending","title":"All Paths From Source to Target","memory":"15.3 MB","code":"class Solution {\npublic:\n    vector<vector<int>> allPathsSourceTarget(vector<vector<int>>& graph) {\n        /*\n        Let's use iterative dfs on this problem with an adjacency list\n\n        We want to remember all of the paths from the start\n\n        I need to mark that I've taken a certain path already\n\n        I need to run dfs on every one of zero's neighbors\n\n\n        When we go through one path and we reach the n -1 th node through dfs, we backtrack and mark each place\n        we just visited through the path as unvisited, so if we go through a different node in the beginning and we\n        end up on the same path, we can include it in the list of paths.\n        */\n\n        vector<vector<int>> paths;\n        vector<bool> marked(graph.size(), false);\n        vector<int> currpath;\n        dfs(0, graph, paths, marked, currpath);\n\n        return paths;\n    }\n\n    void dfs(int node, vector<vector<int>>& graph, vector<vector<int>>& paths, vector<bool>& marked, vector<int> currpath) {\n        int target = graph.size() - 1;\n        marked[node] = true;\n        currpath.push_back(node);\n        if (node == target) {\n            paths.push_back(currpath);\n        }\n        for (int item : graph[node]) {\n            if (!marked[item]) {\n                dfs(item, graph, paths, marked, currpath);\n            }\n        }\n        marked[node] = false;\n        return;\n    }\n};","compare_result":"111111111111111111111111111111","title_slug":"all-paths-from-source-to-target"}