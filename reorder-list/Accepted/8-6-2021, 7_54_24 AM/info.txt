{"id":534265362,"lang":"cpp","time":"6 months, 1 week","timestamp":1628261664,"status_display":"Accepted","runtime":"36 ms","url":"/submissions/detail/534265362/","is_pending":"Not Pending","title":"Reorder List","memory":"17.7 MB","code":"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    void reorderList(ListNode* head) {\n        if (head == nullptr or head->next == nullptr) {\n            return;\n        }\n        //head of first half \n        ListNode* l1 = head;\n        //head of second half \n        ListNode* slow = head;\n        \n        //tail of second half\n        ListNode* fast = head;\n        \n        //tail of first half.\n        ListNode* prev = nullptr; \n        \n        \n        while (fast != nullptr and fast->next != nullptr) {\n            prev = slow;\n            //tail of the first part of the linked list\n            slow = slow->next;\n            //\n            fast = fast->next->next;\n            //\n\n        }\n        \n        prev->next = nullptr; \n        ListNode* l2 = reverselist(slow);\n        //1 -> 2 -> 3 -> 4 -> null;\n        //8 -> 7 -> 6 -> 5 -> null;\n        merge(l1, l2);\n    }\n    \n    \n    \n    ListNode* reverselist(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        ListNode* temp;\n        while (curr != nullptr) {\n            temp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = temp;\n        }\n        return prev;\n    }\n    \n    \n    //1 2 \n    //4 3 \n    \n    void merge(ListNode* l1, ListNode* l2) {\n        while (l1 != nullptr) {\n            //we need to save the l1's next so once you finish linking the top and bottom,\n            //We can link the bottom with the top list, which is l1->next\n            //need temp places to store the next nodes \n            //cause once you change the direction of the current pointers l1 and l2\n            //will not have access to l1->next or l2->next unless you make atemp\n            ListNode* l1_next = l1->next;\n            ListNode* l2_next = l2->next;\n            l1->next = l2;\n            //since l2 starts at the beginning with l1\n            //we can just make the first pointer pointer to the botoom;\n            if (l1_next == nullptr) {\n                //if we're at the tail we should\n                //just halt the process. \n                break;\n            }\n           \n            l2->next = l1_next;\n            //make bottom pointer of l2 point to the next top of l1\n            \n            \n            //move onto the next pointers that need to be arranged.\n            l1 = l1_next;\n            l2 = l2_next;\n        }\n    }\n    \n    \n    \n    \n  \n};","compare_result":"111111111111","title_slug":"reorder-list"}