{"id":544829772,"lang":"cpp","time":"5 months, 2 weeks","timestamp":1630022978,"status_display":"Time Limit Exceeded","runtime":"N/A","url":"/submissions/detail/544829772/","is_pending":"Not Pending","title":"01 Matrix","memory":"N/A","code":"class Solution {\npublic:\n    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {\n        /*\n        BFS Problem\n        A zero already means that the distance is zero. No need to bfs the\n        empty cells already. I need to go through the entire matrix\n        and run a bfs on the 1s and the neighbors. I can count the path\n        that is taken along the bfs from the ones while ignoring the zeros.\n        */\n\n        int path;\n\n        vector<vector<int>> distances(mat.size(), vector<int>(mat[0].size(), 0));\n        vector<vector<bool>> visited(mat.size(), vector<bool>(mat[0].size(), false));\n        for (int i = 0; i < mat.size(); i++) {\n            for (int j = 0; j < mat.at(0).size(); j++) {\n                if (mat[i][j] != 0) {\n                    vector<vector<bool>> visited(mat.size(), vector<bool>(mat[0].size(), false));\n                    path = bfs(mat, i, j, visited);\n                    distances[i][j] = path;\n                }\n            }\n        }\n        return distances;\n\n    }\n\n    int bfs(vector<vector<int>>& mat, int row, int col, vector<vector<bool>>& marked) {\n        queue<pair<int, int>> processn;\n        vector<pair<int, int>> neighbors;\n        pair<int, int> nextnode;\n        int smallpath = 10000;\n        int pathlength;\n        int numneighbors = 1;\n        processn.push({row, col});\n        while (!processn.empty()) {\n            nextnode = processn.front();\n            processn.pop();\n            int currow = nextnode.first;\n            int currcol = nextnode.second;\n            if (mat[currow][currcol] == 0) {\n                int rowdif = abs(row - currow);\n                int coldif = abs(col - currcol);\n                pathlength = rowdif + coldif;\n                smallpath = min(pathlength, smallpath);\n            }\n\n            if (!marked[currow][currcol]) {\n                marked[currow][currcol] = true;\n                neighbors = buildneighbors(currow, currcol);\n                for (pair<int, int> w : neighbors)\n                    if (isValid(w.first, w.second, mat) and !marked[w.first][w.second]) {\n                        processn.push(w);\n                    }\n            }\n        }\n        return smallpath;\n    }\n\n    vector<pair<int, int>> buildneighbors(int currow, int currcol) {\n        vector<pair<int, int>> neighbors;\n        int north = currow - 1;\n        int south = currow + 1;\n        int west = currcol - 1;\n        int east = currcol + 1;\n        neighbors = {{north, currcol}, {south, currcol}, {currow, west}, {currow, east}};\n        return neighbors;\n    }\n\n\n    bool isValid(int row, int col, vector<vector<int>>& image) {\n        return (row >= 0 and row < image.size()) and (col >= 0 and col < image.at(0).size());\n    }\n};","compare_result":"11111111111111111111111111100000000000000000000000","title_slug":"01-matrix"}