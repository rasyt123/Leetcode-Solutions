{"id":544938154,"lang":"cpp","time":"5 months, 2 weeks","timestamp":1630040369,"status_display":"Accepted","runtime":"137 ms","url":"/submissions/detail/544938154/","is_pending":"Not Pending","title":"01 Matrix","memory":"30.1 MB","code":"class Solution {\npublic:\n  vector<vector<int>> updateMatrix(vector<vector<int>>& matrix) {\n        int rows = matrix.size();\n        if (rows == 0)\n            return matrix;\n        int cols = matrix[0].size();\n        vector<vector<int>> dist(rows, vector<int> (cols, INT_MAX));\n        queue<pair<int, int>> q;\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (matrix[i][j] == 0) {\n                    dist[i][j] = 0;\n                    q.push({ i, j }); //Put all 0s in the queue.\n                }\n            }\n        }\n\n        int dir[4][2] = { { -1, 0 }, { 1, 0 }, { 0, -1 }, { 0, 1 } };\n        while (!q.empty()) {\n            pair<int, int> curr = q.front();\n            q.pop();\n            for (int i = 0; i < 4; i++) {\n                int new_r = curr.first + dir[i][0], new_c = curr.second + dir[i][1];\n                if (new_r >= 0 && new_c >= 0 && new_r < rows && new_c < cols) {\n                    if (dist[new_r][new_c] > dist[curr.first][curr.second] + 1) {\n                        dist[new_r][new_c] = dist[curr.first][curr.second] + 1;\n                        q.push({ new_r, new_c });\n                    }\n                }\n            }\n        }\n        return dist;\n    }    /*\n        Methodology/Patterns\n        \n        Most of the time with these questions we want to be taking a non naive approach with the BFS or the DFS. we really dont want to run dfs or bfs for each cell because the run time complexity could be possibly worse than brute force. We want to optimize the naive solution by using a technique called flowing from the ocean.\n        \n        \n        \n        - We only want to bfs once rather than bfsing at each 1. we can bfs through all the zeros and change the respective neighbors of those zeros to be the correct distance from the ones. path from point a to b is the same distance as point b to a. \n\n\n    - 1 + value at the matrix S. Since the -1s are alreacy marked with the distance from the zeros, if we just add \n    to the value of the cell previous to it we will get the current distance from the zero\n    \n    \n    Method:\n    \n    1. We add all of the zeros in the matrix into the bfs queue and mark them as visited. We add\n    the neighbors of the front element of the queue that haven't been visited. for each one of these \n    neighbors that are -1s, we add how far it is away which is 1 + current zero. It's the same as moving from 0 to 1. 0 + 1 = 1 + 0; each one of these neighbors we add to the queue to explore the next level\n    \n    \n    \n\n\n        \n        \n        \n    */\n        \n    \n};","compare_result":"11111111111111111111111111111111111111111111111111","title_slug":"01-matrix"}