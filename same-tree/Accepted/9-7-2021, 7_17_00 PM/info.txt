{"id":551238121,"lang":"cpp","time":"5Â months","timestamp":1631067420,"status_display":"Accepted","runtime":"4 ms","url":"/submissions/detail/551238121/","is_pending":"Not Pending","title":"Same Tree","memory":"10.1 MB","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        /*\n          We can use a depth first search traversing through the nodes p and q at the same time\n          We can compare the values at each of the node.\n          if one is null and the other isnt that basically says that the structure of the trees\n          is not the same so we should return false;\n          \n                    \n          if both p and q are null then we can return trye\n                      \n          if the values at the nodes are different then we should return false\n          \n          Both p and q subtrees should be the same\n        \n        \n        \n    \n        */\n        if (p == nullptr and q == nullptr) {\n            return true;\n        }\n        \n        if ((p == nullptr and q != nullptr) or (q == nullptr and p != nullptr)) {\n            return false;\n        }\n        \n        if (p->val != q->val) {\n            return false;\n        }\n        return isSameTree(p->left, q->left) and isSameTree(p->right, q->right);\n    }\n    \n    \n};","compare_result":"111111111111111111111111111111111111111111111111111111111111","title_slug":"same-tree"}