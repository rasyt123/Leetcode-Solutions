{"id":552864259,"lang":"cpp","time":"5Â months","timestamp":1631326047,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/552864259/","is_pending":"Not Pending","title":"Non-overlapping Intervals","memory":"N/A","code":"class Solution {\npublic:\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        /*\n        Sort intervals by ascending order, no need to sort the \n        intervals by their respective values like rearranging the values of the intervals\n        and putting them into other intervals/\n    \n     \n        Whenever the end interval of the first is greater than the end of the next interval\n        that means that the interval is overlapping \n        Count all overlapping intervals including the duplicates\n        \n        [[1,2],[1,2],[1,2], [1, 5] [2,3] [2,3], [2, 3]]\n        3  4 5 \n       stack [1, 2] , [2, 3], \n        \n        if we have a stack, we can push all of the intervals that we dont want to delete on the top\n        as we iterate, if the interval is the same, then we can just +1 to the counter and \n        \n        if the top of the stack interval end is greater than the end of the one iterating, + 1 \n        to the counter\n        \n        if it's not, just push that item to the top of the stack \n        \n        \n        [1, 2] [1, 5]\n    \n        */\n        sort(intervals.begin(), intervals.end());\n        stack<vector<int>> interval;\n        int intervalcount = 0;\n        for (vector<int> item : intervals) {\n            if (!interval.empty()) {\n                vector<int> result = interval.top();\n                if (item == result or result[1] > item[0]) {\n                    intervalcount += 1;\n                    continue;\n                } \n            }\n            interval.push(item);\n        }\n        return intervalcount;\n        \n    }\n};","compare_result":"1111111111111100000000000000000000000000000000000000110011","title_slug":"non-overlapping-intervals"}