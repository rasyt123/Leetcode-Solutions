{"id":587483171,"lang":"cpp","time":"2 months, 4 weeks","timestamp":1636968805,"status_display":"Accepted","runtime":"8 ms","url":"/submissions/detail/587483171/","is_pending":"Not Pending","title":"Peak Index in a Mountain Array","memory":"11.5 MB","code":"class Solution {\npublic:\n    int peakIndexInMountainArray(vector<int>& arr) {\n        /*\n        Straightforward o(n) solution \n        we go through the vector arr and \n        we check if the the item at the index previous \n        is less than the current value and of the item + 1 \n        ahead of us is less than the current value\n        \n        [24,69,100,99,79,78,67,36,26,19]\n         0  1   2  3  4  5 6  7    8 9 \n         \n         o(log n) solution \n         \n      while (l < r)  \n      \n         if the item at the middle is the one we want:\n            return it \n        otherwise if item previous is greater than the current  or there is no previous\n             we look at left sorted portion\n             r = mid\n        otherwise\n             we look at the right sorted portion \n        \n        [24, 69, 100, 99]\n         0   1   2    3 \n         \n         [100, 99]\n           2   3 \n           l   r\n           \n           [0, 2, 1, 0]\n            0  1  2  3}\n  }\n    */\n        \n    int l = 0;\n    int r = arr.size() - 1;\n    while (l < r) {\n            int m = l + (r - l) / 2;\n            if (arr[m] > arr[m - 1] and arr[m] > arr[m + 1]) {\n                return m;\n            } else if (arr[m - 1] > arr[m]) {\n                r = m;\n            } else {\n                l = m + 1;\n            }\n        \n    }\n    return 0;\n  \n    \n \n    }\n};","compare_result":"1111111111111111111111111111111111","title_slug":"peak-index-in-a-mountain-array"}