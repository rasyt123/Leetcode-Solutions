{"id":537080639,"lang":"python3","time":"6Â months","timestamp":1628726536,"status_display":"Accepted","runtime":"900 ms","url":"/submissions/detail/537080639/","is_pending":"Not Pending","title":"3Sum","memory":"16.9 MB","code":"class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        res = []\n        nums.sort()\n        for i in range(len(nums) - 2):\n            #This is len(nums) - 2 because you can't find anymore triplets when i is len(nums) - 2 \n            #or greater\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            #we dont want to recompute all the same triplets again and we want to save\n            #computation time\n            l, r = i + 1, len(nums) - 1\n            #we use two sum algorithm here but with the element at nums[i] we run two sum on every single \n            #number in the array \n            while l < r:\n                #when l crosses r we've checked all of the items in between l and r that could be possible\n                #solutions, so we should just halt the loop\n                s = nums[i] + nums[l] + nums[r];\n                if s < 0:\n                    #the sum is too small so we should try shifting the left pointer to the right and see\n                    #try computing the sum of the next biggest number\n                    l += 1\n                elif s > 0:\n                    #sum is too big so we should try using the next smallest number and see if it matches up \n                    #with the target\n                    r -= 1\n                else:\n                    #the sum is the target so we can add all the numbers that make up the target which are the elements\n                    #at the pointers plus the item ur currently checking\n                    res.append((nums[i], nums[l], nums[r]))\n                    #once we find a match, there could be other triplets hiding so we need \n                    #to skip through all of the duplicates so we don't add extra triplets\n                    while l < r and nums[l] == nums[l + 1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r - 1]:\n                        r -= 1\n                    #with duplicates we increment the pointers up until the last duplicate but the pointers are still on duplicates\n                    #so we need to increment them one last time \n                    l += 1; r-= 1;\n        return res","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"3sum"}