{"id":542108460,"lang":"cpp","time":"5 months, 3 weeks","timestamp":1629583435,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/542108460/","is_pending":"Not Pending","title":"Pacific Atlantic Water Flow","memory":"N/A","code":"class Solution {\npublic:\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\n\n        /*\n        Depth first search problem\n\n        Pacific ocean touches island's left and top edges\n\n        Atlantic ocean touches right islands'right and bottom edges\n\n        hold neighbors with adjacency list\n\n\n        we need to mark all of the rows and cols we visit with a visited vector\n        we need to run a depth first search on every cell and check whether or not\n        from the cell we've hit one end in the pacific ocean and one end in the atlantic\n        ocean\n\n        we can have a data structure that holds the boolean values of atlantic\n        and pacific oceans\n\n\n\n        I need a function that builds all of the neighbors to go through\n        use vector or map with pairs\n\n        isPacific\n        we need a function that checks if the current column and row are out of\n        bounds to the left and right\n\n        Pacific ocean:  currrow - 1 < 0 or currcol - 1 < 0\n\n\n        isAtlantic\n        Atlantic ocean: currow + 1 > 0 or currcol + 1 > 0\n        5 - 3 3 4 1\n\n        */\n        int num_rows = heights.size();\n        int num_cols = heights.at(0).size();\n        vector<int> coords;\n\n        vector<vector<int>> result;\n\n        vector<pair<int, int>> neighbors;\n        \n        vector<vector<bool>> visited(num_rows, vector<bool>(num_cols, false));\n\n        vector<bool> bothpaths{false, false};\n\n\n\n        for (int row = 0; row <= num_rows - 1; row++) {\n            for (int col = 0; col <= num_cols - 1; col++) {\n                neighbors = buildneighbors(row, col);\n                dfs(row, col, bothpaths, visited, neighbors, heights);\n                if (bothpaths[0] and bothpaths[1]) {\n                    coords = {row, col};\n                    result.push_back(coords);\n                    coords.clear();\n                }\n                bothpaths[0] = false;\n                bothpaths[1] = false;\n            }\n        }\n\n        return result;\n\n    }\n\n    vector<pair<int, int>> buildneighbors(int currow, int currcol) {\n        vector<pair<int, int>> neighbors;\n        int north = currow - 1;\n        int south = currow + 1;\n        int west = currcol - 1;\n        int east = currcol + 1;\n        neighbors = {{north, currcol}, {south, currcol}, {currow, west}, {currow, east}};\n        return neighbors;\n    }\n\n\n    bool isValid(int row, int col, vector<vector<int>>& heights) {\n        return (row >= 0 and row < heights.size()) and (col >= 0 and col < heights.at(0).size());\n\n    }\n\n    void dfs(int row, int col, vector<bool>& bothpaths, vector<vector<bool>>& visited, vector<pair<int, int>> neighbors, vector<vector<int>>& heights) {\n        visited[row][col] = true;\n        neighbors = buildneighbors(row, col);\n        if (row - 1 < 0 or col - 1 < 0) {\n            bothpaths[0] = true;\n\n        }\n\n        if (row + 1 > visited.size() - 1 or col + 1 > visited.at(0).size() - 1) {\n            bothpaths[1] = true;\n        }\n\n        if (bothpaths[0] and bothpaths[1]) {\n            return;\n        }\n\n        for (pair<int,int> items : neighbors) {\n            if (isValid(items.first, items.second, heights) and heights[items.first][items.second] <= heights[row][col] and !visited[items.first][items.second]) {\n                dfs(items.first, items.second, bothpaths, visited, neighbors, heights);\n            }\n        }\n\n\n        return;\n    }\n};\n","compare_result":"00100000000000000000000000000000000010000000000001100000000100000000000000000000000000001001000000000000000000000","title_slug":"pacific-atlantic-water-flow"}