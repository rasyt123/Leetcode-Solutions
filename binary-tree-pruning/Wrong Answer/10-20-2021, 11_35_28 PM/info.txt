{"id":574749543,"lang":"cpp","time":"3 months, 3 weeks","timestamp":1634798128,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/574749543/","is_pending":"Not Pending","title":"Binary Tree Pruning","memory":"N/A","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* pruneTree(TreeNode* root) {\n        /*\n        Postorder traversal\n        The leaves of every binary tree that are zeros basically\n        need to be pruned \n        \n        once we prune leaves, we are back to the base case that the root is a leaf that is zero \n        \n        if the root is equal to null:\n            return null:\n        root->left = dfs(root->left, ) \n        root->right =\n        \n        if both rootleft and rootright are null and root->val = 0:\n            return null\n        return root \n        */\n        TreeNode* roots = dfs(root);\n        return root;\n        \n    }\n    \n    \n    TreeNode* dfs(TreeNode* root) {\n        if (root == nullptr) {\n            return nullptr;\n        }\n        root->left = dfs(root->left);\n        root->right = dfs(root->right);\n        if (root->left == nullptr and root->right == nullptr and \n           root->val == 0) {\n            return nullptr;\n        }\n        return root;\n    }\n};","compare_result":"111111011111111111111111111111","title_slug":"binary-tree-pruning"}