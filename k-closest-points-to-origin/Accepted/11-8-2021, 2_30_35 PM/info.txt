{"id":584172396,"lang":"cpp","time":"3Â months","timestamp":1636410635,"status_display":"Accepted","runtime":"240 ms","url":"/submissions/detail/584172396/","is_pending":"Not Pending","title":"K Closest Points to Origin","memory":"73.1 MB","code":"class Solution {\npublic:\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\n        /*\n        From the origin, we first loop through the vector of vector of points\n        and then calculate the distances from the origin. We can create \n        a pair with the distances and the points, and push them onto a priority queue,\n        but with the distances as the first argument, so the points with the smallest distance from the origin are up first\n        \n        \n        we then pop each of the elements from the priority queue one by one, decrementing a variable equal to k \n        until it reaches zero \n        */\n        priority_queue<pair<double, vector<int>>, vector<pair<double, vector<int>>>, greater<pair<double, vector<int>>>> pq;\n        vector<vector<int>> finalvec;\n        double distance;\n        int j = k;\n        for (int i = 0; i < points.size(); i++) {\n           distance = sqrt(pow(points[i][0], 2) + pow(points[i][1], 2));\n           pair<double, vector<int>> newp = {distance, points[i]};\n           pq.push(newp);\n        }\n        while (!pq.empty()) {\n            if (j == 0) {\n                break;\n            }\n            finalvec.push_back(pq.top().second);\n            pq.pop();\n            --j;\n        }\n        \n        return finalvec;\n        \n      \n        \n        \n    }\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"k-closest-points-to-origin"}