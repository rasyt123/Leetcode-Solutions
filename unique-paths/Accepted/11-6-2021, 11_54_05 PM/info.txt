{"id":583316129,"lang":"cpp","time":"3Â months","timestamp":1636268045,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/583316129/","is_pending":"Not Pending","title":"Unique Paths","memory":"6.6 MB","code":"class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        /*\n        The number of unique paths is the sum of the number of unique paths from the tile to the right of starting \n        point + the number of unique paths from the tile that is at the bottom of the starting \n        \n        Overlapping Substructure: We break this into smaller unique subproblems as in for the starting tile, this solution to \n        this problem depends on a subproblem where we have to find the number of unique \n        \n        We cache the \n        m = m - 1\n        n = n - 1 \n        \n        Where j and i are zero  \n        i, j+1, i+1,  j\n       \n    \n        if i == m-1 and j == n - 1:\n            dp[i][j] = 1;\n            return dp[i][j];\n        if (i and j are invalid):\n            return 0    \n        otherwise if (dp[i][j] != 0):\n            return dp[i][j]   \n        otherwise:\n            to the right                   and down \n            dp[i][j] = numuniquepaths(dp, i, j + 1) + numuniquepaths(dp, i + 1, j)\n        return dp[i][j]\n        */\n        \n        \n        \n        /*\n        //Recursive Appraoch\n//This will give a TLE\n  int solve(int i,int j,int m,int n)\n    {\n        if(i>=m||j>=n)\n            return 0;\n        if(i==m-1&&j==n-1)\n            return 1;\n        return solve(i+1,j,m,n)+solve(i,j+1,m,n);\n    }\n    int uniquePaths(int m, int n) {\n        return solve(0,0,m,n);\n    }\n\n//DP(recursive+memoization)\n    int solve(int i,int j,int m,int n,vector<vector<int>> &dp)\n    {\n        if(i>=m||j>=n)\n            return 0;\n        if(i==m-1&&j==n-1)\n            return 1;\n        if(dp[i][j]!=-1)\n            return dp[i][j];\n        \n        return dp[i][j]=solve(i+1,j,m,n,dp)+solve(i,j+1,m,n,dp);\n    }\n    int uniquePaths(int m, int n) {\n      vector<vector<int>> dp(m,vector<int>(n,-1));\n        return solve(0,0,m,n,dp);\n    }\n//TC:O(m*n)\n//SC:O(m*n)\n\n//DP(Bottom-Up Appraoch)\n  int uniquePaths(int m, int n) {\n     int dp[m][n];\n        for(int i=0;i<m;i++)\n        {\n            for(int j=0;j<n;j++)\n            {\n                if(i==0||j==0)\n                    dp[i][j]=1;\n                else\n                    dp[i][j]=dp[i-1][j]+dp[i][j-1];\n            }\n        }\n        return dp[m-1][n-1];\n    }\n        \n        \n        */\n        vector<vector<int>> dp(m, vector<int> (n, 0));\n        int result = numuniquepaths(dp, m, n, 0, 0);\n        return result;\n    }\n    \n    \n    int numuniquepaths(vector<vector<int>>& dp, int m, int n, int i, int j) {\n        if (i >= m or j > n - 1) {\n            return 0;\n        }\n        if (i == m - 1 and j == n - 1) {\n            dp[i][j] = 1;\n            return dp[i][j];\n        }\n      \n         if (dp[i][j] != 0) {\n            return dp[i][j];\n        } else {\n            dp[i][j] = numuniquepaths(dp, m, n, i, j + 1) + numuniquepaths(dp, m, n, i + 1, j);\n        }\n        return dp[i][j];\n        \n    }\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111","title_slug":"unique-paths"}