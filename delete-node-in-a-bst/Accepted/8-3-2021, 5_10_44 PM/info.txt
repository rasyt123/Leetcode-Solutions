{"id":532904261,"lang":"cpp","time":"6 months, 1 week","timestamp":1628035844,"status_display":"Accepted","runtime":"32 ms","url":"/submissions/detail/532904261/","is_pending":"Not Pending","title":"Delete Node in a BST","memory":"32.8 MB","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* deleteNode(TreeNode* root, int key) {\n        TreeNode* parent;\n        TreeNode* temp;\n        if (root == nullptr) {\n            return nullptr;\n        }\n        if (root->left == nullptr and root->right == nullptr and key == root->val) {\n            return nullptr;\n        }\n\n        parent = nullptr;\n        temp = deletezanode(root, parent, key);\n\n        return temp;\n\n    }\n\n    TreeNode* findminnode(TreeNode* root) {\n        TreeNode* currnode = root;\n        while (currnode->left != nullptr) {\n            currnode = currnode->left;\n        }\n        return currnode;\n\n    }\n\n\n    //When we delete a node, we want to replace the current node with the minimum on the right subtree\n    // which means picking at a leaf all the way down to the left of the right subtree\n    //IT would be a pain in the ass to replace the current node with a node that isnt a leaf that has more than\n    // one child\n    //If you cant go left then the right subtree node is all you have for a replacement\n    //\n    //\n\n\n    TreeNode* deletezanode(TreeNode* root, TreeNode* parent, int key) {\n        TreeNode *minnode;\n        if (root == nullptr) {\n            return nullptr;\n        }\n        if (root->val > key) {\n            //if the root val is bigger than the key, we need to go the left subtree\n            //each recursive call will return the node it's currently on\n            root->left = deletezanode(root->left, root, key);\n        } else if (root->val < key) {\n            //if the root val is smaller than the key, we need to search to the right subtree\n            root->right = deletezanode(root->right, root, key);\n        } else {\n            // 3 scenarious of deletion \n            \n            \n            //if the root is a leaf, just return null so the previous node recursive call\n            // can connect its pointer \n            if (root->left == nullptr and root->right == nullptr) {\n                return nullptr;\n            } else if (root->left == nullptr) {\n                return root->right;\n                //when u delete a node with only one child, just return the current node's child so the \n                //previous node will take ownership of it\n            } else if (root->right == nullptr) {\n                //when u delete a node with only one child, just return the current node's child so the \n                //previous node will take ownership of it.\n                return root->left;\n            }\n            \n            \n            \n            //if the node u want to delete has multiple children\n            //replace the current node with the minimum value from the right subtree\n            //the node that was going to be the replaced will be checked by the function so it can be queued \n            //up for removal with the three cases. \n        \n            minnode = findminnode(root->right);\n            root->val = minnode->val;\n            root->right = deletezanode(root->right, root, minnode->val);\n\n        }\n        return root;\n    }\n    };\n\n","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"delete-node-in-a-bst"}