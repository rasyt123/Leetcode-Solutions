{"id":532887322,"lang":"cpp","time":"6 months, 1 week","timestamp":1628032094,"status_display":"Accepted","runtime":"20 ms","url":"/submissions/detail/532887322/","is_pending":"Not Pending","title":"Delete Node in a BST","memory":"32.7 MB","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* deleteNode(TreeNode* root, int key) {\n        TreeNode* parent;\n        TreeNode* temp;\n        if (root == nullptr) {\n            return nullptr;\n        }\n        if (root->left == nullptr and root->right == nullptr and key == root->val) {\n            return nullptr;\n        }\n\n        parent = nullptr;\n        temp = deletezanode(root, parent, key);\n\n        return temp;\n\n    }\n\n    TreeNode* findminnode(TreeNode* root) {\n        TreeNode* currnode = root;\n        while (currnode->left != nullptr) {\n            currnode = currnode->left;\n        }\n        return currnode;\n\n    }\n\n\n    //When we delete a node, we want to replace the current node with the minimum on the right subtree\n    // which means picking at a leaf all the way down to the left of the right subtree\n    //IT would be a pain in the ass to replace the current node with a node that isnt a leaf that has more than\n    // one child\n    //If you cant go left then the right subtree node is all you have for a replacement\n    //\n    //\n\n\n    TreeNode* deletezanode(TreeNode* root, TreeNode* parent, int key) {\n        TreeNode *minnode;\n        if (root == nullptr) {\n            return nullptr;\n        }\n        if (root->val > key) {\n            root->left = deletezanode(root->left, root, key);\n        } else if (root->val < key) {\n            root->right = deletezanode(root->right, root, key);\n        } else {\n            if (root->left == nullptr and root->right == nullptr) {\n                return nullptr;\n            } else if (root->left == nullptr) {\n                return root->right;\n            } else if (root->right == nullptr) {\n                return root->left;\n            }\n            minnode = findminnode(root->right);\n            root->val = minnode->val;\n            root->right = deletezanode(root->right, root, minnode->val);\n\n        }\n        return root;\n    }\n    };\n\n","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"delete-node-in-a-bst"}