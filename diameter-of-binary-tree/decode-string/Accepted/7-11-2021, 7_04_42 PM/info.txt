{"id":521070992,"lang":"c","time":"7Â months","timestamp":1626055482,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/521070992/","is_pending":"Not Pending","title":"Decode String","memory":"6.4 MB","code":"struct node_times {\n    int times;\n    struct node_times* next;\n};\nstruct node_char {\n    char c;\n    struct node_char* next;\n};\nvoid push_num(struct node_times** head, int num) {\n    struct node_times* new_node = (struct node_times*)malloc(sizeof(struct node_times));\n    new_node->times = num;\n    new_node->next = *head;\n    *head = new_node;\n}\nvoid push_char(struct node_char** head, char c) {\n    struct node_char* new_node = (struct node_char*)malloc(sizeof(struct node_char));\n    new_node->c = c;\n    new_node->next = *head;\n    *head = new_node;\n}\nint pop_number(struct node_times** head) {\n    struct node_times* tmp = *head;\n    int ret_n = tmp->times;\n    *head = (*head)->next;\n    free(tmp);\n    return ret_n;\n}\nchar pop_char(struct node_char** head) {\n    struct node_char* tmp = *head;\n    char ret_c = tmp->c;\n    (*head) = (*head)->next;\n    free(tmp);\n    return ret_c;\n}\nint get_word_size(struct node_char* head) {\n    int size = 0;\n    while (head) {\n        if (head->c == '[') break;\n        size++;\n        head = head->next;\n    }\n    return size;\n}\nchar* decodeString(char* s) {\n    struct node_times* head_num_stack = NULL;\n    struct node_char* head_char_stack = NULL;\n    int i = 0;\n    int w_size;\n    int k;\n    while (s[i]) {\n        // if its a number push it to number's stack\n        if (s[i] >= '0' && s[i] <= '9') {\n            int num = atoi(&s[i]);\n            while (s[i] >= '0' && s[i] <= '9') i++;// increment index to pass by the number\n            // push the number to numbers stack\n            push_num(&head_num_stack, num);\n        }\n        else if (s[i] > '9' && s[i] != ']') {\n            // if its any letter but not ']' then just push it to char stack\n            push_char(&head_char_stack, s[i]);\n            i++;\n        }\n        else if (s[i] == '[') {\n            // if its an opnening bracket push it to char stack\n            push_char(&head_char_stack, '[');\n            i++;\n        }\n        else if (s[i] == ']') {\n            // here we need building word procedure to begin\n            w_size = get_word_size(head_char_stack); // get word size\n            int n_times = pop_number(&head_num_stack); // get how much we need to repeat the word\n            char* word = (char*)malloc(w_size * sizeof(char));// allocate memory for word for temporary work\n            // read word chars into temporary word, also empty it from chars stack\n            for (k = 0; k < w_size; k++) {\n                word[k] = pop_char(&head_char_stack);\n            }\n            // now we have the word we need to push it the multiplier amount of times:\n            // we have to push it in reversed order because we pulled it from char stack ( which is reversed )\n           \n            pop_char(&head_char_stack); // get rid of the opening bracket at char stack - '['\n            // now we need to push the word n_times\n            for (; n_times > 0; n_times--) {\n                for (k = w_size - 1; k >= 0; k--) {\n                    push_char(&head_char_stack, word[k]);\n                }\n            }\n            free(word); // free the temp string\n            i++;\n        }\n    }\n    // now we have the complete decoded string at the char_stack, all we need to do is to pop it out char by char and then reverse the chars order!\n\t // and dont forget we need 1 null byte for ending string Muhahaha!\n    w_size = get_word_size(head_char_stack);// get overall string size - how many chars\n    char* res = (char*)calloc(w_size + 1, sizeof(char)); // allocate memory for solution string\n    //free(s); // free memory of instruction string - this is optional \n    for (k = w_size - 1; k >= 0; k--) res[k] = pop_char(&head_char_stack);\n    return res;\n}","compare_result":"1111111111111111111111111111111111","title_slug":"decode-string"}