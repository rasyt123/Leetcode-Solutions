{"id":552420705,"lang":"cpp","time":"5Â months","timestamp":1631249509,"status_display":"Accepted","runtime":"61 ms","url":"/submissions/detail/552420705/","is_pending":"Not Pending","title":"Merge k Sorted Lists","memory":"14.1 MB","code":"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        /*\n            store all of the linkedlist nodes\n            in a hashmap with the value as the first element of the pair\n            and the node itself as the second\n\n            add all of the linked list nodes into a binary min heap\n            with the value associated with the node\n\n            go through the entire priority queue and construct the linked list\n            with a dummy node.\n        */\n        if (lists.size() == 0) {\n            return nullptr;\n        }\n        ListNode* dummy;\n        ListNode* newnode;\n        ListNode* curr;\n        dummy = new ListNode;\n        ListNode* other = dummy;\n        priority_queue<pair<int, ListNode*>, vector<pair<int, ListNode*>>, greater<pair<int, ListNode*>>> pq;\n        for (int i = 0; i < lists.size(); i++) {\n            curr = lists[i];\n            while (curr != nullptr) {\n                pq.push({curr->val,curr});\n                curr = curr->next;\n            }\n        }\n        while (!pq.empty()) {\n            auto node = pq.top();\n            dummy->next = node.second;\n            dummy = dummy->next;\n            pq.pop();\n        }\n        return other->next;\n\n    }\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"merge-k-sorted-lists"}