{"id":551796748,"lang":"cpp","time":"5Â months","timestamp":1631151466,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/551796748/","is_pending":"Not Pending","title":"Binary Tree Maximum Path Sum","memory":"N/A","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int maxPathSum(TreeNode* root) {\n        /*\n        Preorder traversal + helper \n        \n        Paths can have the same sum but also if you traverse from the end to the start node or\n        you traverse from the start to the end node, then you will have the same sum.\n        \n        \n        If I were to do this bottom up from a particular path \n        I would need the sum of the left and right subtree and the current node\n        helper funciton:\n        if the root is null:\n            we should just return zero;\n        \n        \n        item max(current + leftsubtree, current + rightsubtree)\n        item2 = max(current + leftsubtree + rightsubtree, item);\n        return item2;\n     \n        dfs(root->left);\n        dfs(root->right);\n        \n\n        */\n        int ans;\n        ans = root->val;\n        dfs(root, ans);\n        if (ans > maxpathsum) {\n            return ans;\n        } else {\n            return maxpathsum;\n        }\n    }\n    \n    int calculatesum(TreeNode* root) { \n        int leftorright;\n        int bothsub;\n        \n       \n        if (!root) {\n            return 0;\n        }\n        \n        if (root->left == nullptr and root->right == nullptr) {\n            return root->val;\n        }\n         int current = root->val;\n        //  -10 + 9,  20 + 15 , 20 + 7 = 2\n        leftorright = max(current + calculatesum(root->left), current + calculatesum(root->right));\n        bothsub = calculatesum(root->left) + current + calculatesum(root->right);\n        if (bothsub > maxpathsum) {\n            maxpathsum = bothsub;\n        }\n        return leftorright;\n        \n    }\n    \n    \n    void dfs(TreeNode* root, int& ans) {\n        int sum;\n        if (!root) {\n            return;\n        }\n        \n        sum = calculatesum(root);\n        if (sum > ans) {\n            ans = sum;\n        }\n        if (root->val > ans) {\n            ans = root->val;\n        }\n        dfs(root->left, ans);\n        dfs(root->right, ans);\n    }\n    \n    private:\n        int maxpathsum = INT_MIN;\n};","compare_result":"1111111111111111111111111111111111111111111111111111110111111111111111111111111111111101111000","title_slug":"binary-tree-maximum-path-sum"}